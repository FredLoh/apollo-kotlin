---
title: Persisted queries 
description: Secure your graph while minimizing request latency
---

Apollo supports two separate but related features called **automatic persisted queries** (APQs) and **persisted queries**.
With both features, clients can execute a GraphQL operation by sending an operation's ID instead of the entire operation string. An operation's ID is a hash of the full query string. 

Querying by ID can significantly reduce latency and bandwidth usage. Hashed queries are also sent by default using HTTP `GET` instead of the default `POST`, making them easier to cache in your edge network.

## Differences between persisted queries and APQs

With APQs, if the server can't find the operation ID the client provides, the server returns an error indicating that it needs the full operation string. If the Apollo Kotlin client receives this error, it automatically retries the operation with the full operation string.

The persisted queries feature requires operations to be preregistered in a **persisted query list** (**PQL**).
This allows the PQL to act as a safelist of trusted operations made by your first-party apps. As such, persisted queries is a security feature as much as a performance one.

If you _only_ want to improve request latency and bandwidth usage, APQs addresses your use case. If you _also_ want to secure your supergraph with operation safelisting, you should preregister trusted operations in a PQL.

For more details on differences between persisted queries and APQs, see the [GraphOS persisted queries documentation](/graphos/operations/persisted-queries#differences-from-automatic-persisted).

## Requirements

You can use APQs with the following versions of Apollo Kotlin, Apollo Server, and Apollo Router:
- Apollo Kotlin (v1.0.0+)
- [Apollo Server](/apollo-server/) (v1.0.0+)
- [Apollo Router](/router) (v0.1.0+)

> **Note:** You can use _either_ Apollo Server _or_ Apollo Router for APQs. They don't need to be used together.

Persisted queries is currently in [preview](/resources/product-launch-stages#preview) and has the following requirements:
- Apollo Kotlin (v3.8.2+)
- [Apollo Router](/router) (v1.25.0+)
- [GraphOS Enterprise plan](/graphos/enterprise/)

## Implementation steps

Both persisted queries and APQs require you to configure your client makes requests. If you intend to use persisted queries for safelisting, you also need to generate the operations manifest.

We recommend you follow this order while implementing:

1. **For persisted queries only**: Generate the operation manifest
1. **For persisted queries only**: Publish the operation manifest
1. **For both persisted queries and APQs**: Enable persisted queries on `ApolloClient`

The rest of this article details these steps.

Persisted queries also requires you to create and link a PQL, and to configure your router. For more information on the other configuration aspects of persisted queries, see the [GraphOS persisted queries documentation](/graphos/operations/persisted-queries).

### 1. Generate the operation manifest

> This step is only required for implementing safelisting with persisted queries. It is _not_ required for APQs.

The operation manifest acts as a safelist of trusted operations the [Apollo Router](/router/) can check incoming requests against. 

To generate the operation manifest, set `operationManifestFormat` to `"persistedQueryManifest"` in your Gradle script:

```kotlin
// build.gradle.kts
apollo {
  service("api") {
    packageName.set("com.example")
    
    // Enable generation of the operation manifest
    operationManifestFormat.set("persistedQueryManifest") // highlight-line 
  }
}
```

The operation manifest is generated during code generation. This will happen automatically every time you build your project or you can trigger it manually by executing the `generateApolloSources` Gradle task. 

The operation manifest is generated in `build/generated/manifest/apollo/$serviceName/persistedQueryManifest.json`, where `$serviceName` is `"api"` here. The resulting operation manifest looks something like this:

```json title="persistedQueryManifest.json"
{
  "format": "apollo-persisted-query-manifest",
  "version": 1,
  "operations": [
    {
      "id": "e0321f6b438bb42c022f633d38c19549dea9a2d55c908f64c5c6cb8403442fef",
      "body": "query GetItem { thing { __typename } }",
      "name": "GetItem",
      "type": "query"
    }
  ]
}
```

### 2. Publish operation manifests

> This step is only required for implementing safelisting with persisted queries. It is _not_ required for APQs.

<blockquote>

Ensure your Rover CLI version is `0.17.2` or later. Previous versions of Rover don't support publishing operations to a PQL.
[Download the latest version.](/rover/getting-started/)

</blockquote>

If you want to preregister your manifest as a safelist of trusted operations, you need to publish it to a PQL using the [Rover CLI](/rover/):

```bash title="Example command"
rover persisted-queries publish my-graph@my-variant \
  --manifest ./persistedQueryManifest.json
```

- Replace `my-graph@my-variant` with the **graph ref** of _any_ variant your PQL is [linked to](/graphos/operations/persisted-queries#12-link-the-pql-to-variants). Your platform team can provide this for you.
    - Graph refs have the format `graph-id@variant-name`.
- For the `--manifest` option, provide the path to the manifest you want to publish.

**The above command does the following:**

1. It publishes all operations in the provided manifest file to the PQL linked to the specified variant.
    - Publishing a manifest to a PQL is additive. Any _existing_ entries in the PQL remain.
    - If you publish an operation with the same `id` but different details from an existing entry in the PQL, the entire publish command fails with an error.

2. It updates any _other_ variants that the PQL is applied to so that routers associated with those variants can fetch their updated PQL.

As with manifest generation, you can execute this command in your CI/CD pipeline to publish new operations as part of your app release process.

### 3. Enable persisted queries on `ApolloClient`

Once you've configured your code generation to include operation IDs, you can update your client to query by operation ID rather than the full operation string. This configuration is the same whether you're using APQs or persisted queries. Call `autoPersistedQueries()` on your `ApolloClient.Builder`:

```kotlin
val apolloClient = ApolloClient.Builder()
  .serverUrl("https://...")
  .autoPersistedQueries()
  .build()
```

Once APQs are enabled on your ApolloClient, hashed queries are sent by default.

You may want to disable persisted queries for certain queries, for instance to avoid any caching when the data is updated often. In order to do that, set `enableAutoPersistedQueries` to false on the `ApolloCall`:

```kotlin
apolloClient.query(myQuery).enableAutoPersistedQueries(false).toFlow()
```

## Custom ID for Persisted Queries 

By default, Apollo uses `Sha256` hashing algorithm to generate an ID for the query. To provide custom ID generation logic, use the option - `operationIdGenerator` which accepts an `instance` that implements the `OperationIdGenerator` interface (`com.apollographql.apollo3.compiler.OperationIdGenerator`) as the input. This option can be used to either specify a different hashing algorithm or to fetch the persisted query ID from a different place - e.g. a service or a CLI.

Example Md5 hash generator:

<MultiCodeBlock>

```kotlin
apollo {
  service("service") {
    operationIdGenerator.set(object : com.apollographql.apollo3.compiler.OperationIdGenerator {
      override val version = "my-md5-version1"

      override fun apply(operationDocument: String, operationName: String): String {
        return operationDocument.md5()
      }
    })
  }
}
```

```groovy
import com.apollographql.apollo3.compiler.OperationIdGenerator

apollo {
  service("service") {
    operationIdGenerator = new OperationIdGenerator() {
      String apply(String operationDocument, String operationName) {
        return operationDocument.md5()
      }

      /**
       * Use this version override to indicate an update to the implementation.
       * This forces gradle to recompile models.
       */
      String version = "my-md5-v1"
    }
  }
}
```

</MultiCodeBlock>

### Versioning Id Generator

The result of the ID generator is cached. The cache is not updated when the implementation of the ID Generator changes. To indicate an update to the implementation of the ID Generator, change the `version` override as shown in the above example.
